import logging
import archi.configarchi as conf
import networkx as nx
from dash import Dash, html, dcc, Input, Output
import plotly.graph_objs as go
import pandas as pd
from archi.common import log_function_call

mlogger = logging.getLogger('archi-external-use.exploitgraph')

@log_function_call
def prepareBusinessCapabilitiesTreemap(viewAsGraph: nx.MultiDiGraph) -> conf.Lists:
    '''
        This function is dedicatd to archi views with only nodes having nestable child nodes (see conf.SuitableRelationship)
        It generates the lists usable by pandas and plotly
    '''

    @log_function_call
    def assignParents(lists: conf.Lists) -> None:
        if len(lists.childs) > 0:
            for k, v in lists.childs.items():
                mlogger.debug(f'key : {k}, value : {v}')
                if len(v) > 0:
                    for child in v:
                        try:
                            i = lists.ids.index(child)
                            lists.parents[i] = k
                        except ValueError:
                            mlogger.warning('Child node ({child}) not found in lists.ids. Strange, a bug must lie within the code')
        else:
            mlogger.debug('lists.childs is empty')

    @log_function_call
    def walkgraph(MDG: nx.MultiDiGraph,  names: dict, current_node: list, startLevel: int, lists: conf.Lists) -> tuple:

        @log_function_call
        def continue_walk(e: dict) -> bool:
            mlogger.debug(f'dictionnary received : {e}')
            relationshipValues = [v for v in e[0].values()]
            listOk = [r for r in conf.SuitableRelationship.list() if r in relationshipValues]
            if len(listOk) > 0:
                mlogger.debug('found a suitableRelationship -> returning True')
                return True
            else:
                return False
                        
        mlogger.debug(f'current_node : {current_node}')
        levelPlusOne = startLevel + 1
        nextNodes = []

        try:
            if len(nx.edges(MDG, current_node)) > 0:
                childedges = nx.edges(MDG, current_node)
                for e in childedges:
                    mlogger.debug(f"edges : {e}")
                    mlogger.debug(f"list of edges {MDG.adj[e[0]][e[1]]}")

                    # Add the first node in the list                
                    if e[0] not in lists.ids: 
                        lists.ids.append(e[0])
                        lists.levels.append(startLevel)
                        lists.parents.append('')
                        try:
                            lists.names.append(names[e[0]])
                            lists.textsinfo.append(names[e[0]])
                        except ValueError as ve:
                            mlogger.info(f"the node {e[0]} has no name")
                    if e[0] not in lists.childs:
                        lists.childs[e[0]] = []
                    try:
                        i = nextNodes.index(e[1]) #if there are several edges betweens e[0] and e[1] this test prevents duplicates
                    except ValueError:
                        if continue_walk(MDG.adj[e[0]][e[1]]):
                            nextNodes.append(e[1])
                            lists.ids.append(e[1])
                            lists.levels.append(levelPlusOne)
                            lists.parents.append('')
                            try:
                                lists.names.append(names[e[1]])
                                lists.textsinfo.append(names[e[1]])
                            except ValueError as ve:
                                mlogger.info(f"the node {e[1]} has no name")
                            ch = lists.childs[e[0]]
                            ch.append(e[1])
                walkgraph(MDG, names, nextNodes, levelPlusOne, lists)
            else: # I reached the leaves
                    for l in current_node:
                        try:
                            i = lists.ids.index(l)
                        except ValueError:
                            lists.ids.append(l)
                            lists.levels.append(startLevel)
                            lists.parents.append('')
                            try:
                                lists.names.append(names[l])
                                lists.textsinfo.append(names[l])
                            except ValueError as ve:
                                mlogger.info(f"the node {l} has no name")
        except Exception as e:
            mlogger.critical(f'Unexpected error in function prepareCapabilitiesTreemap() : {type(e)}{e.args}')

    lists = conf.Lists()
    listOfTopLevelsNodes = [n for n,d in viewAsGraph.in_degree() if d==0]
    if len(listOfTopLevelsNodes) > 0:
        for topLevelNode in listOfTopLevelsNodes:
            mlogger.debug(f'current top node : {topLevelNode}')
            names = nx.get_node_attributes(viewAsGraph, conf.ToStore.EN.value)
            startLevel = 0
            walkgraph(viewAsGraph, names, [topLevelNode], startLevel, lists)
        assignParents(lists)

    return lists

def callDashtreemap(app: Dash, lists: conf.Lists):
    
    df = pd.DataFrame() 
    df['parent'] = lists.parents 
    df['ids'] = lists.ids 
    #df['value']= size 
    df['level'] = lists.levels
    df['hovertext'] = lists.textsinfo
    df['label'] = lists.textsinfo
    
    app.layout = html.Div([
    dcc.Graph(id='graph-with-slider'),
    dcc.Slider(
        0,
        3,
        step=None,
        value=3,
        marks = {0 : 'TopLevel', 1: 'Level1', 2: 'Level2', 3: 'Level3'},
        id='sliderVal'
    )
])


    @app.callback(
        Output('graph-with-slider', 'figure'),
        Input('sliderVal', 'value'))
    def update_figure(sliderVal):

        fig = go.Figure()
        fig.add_trace(go.Treemap(
            ids = df[df['level']<=sliderVal]['ids'],
            labels = df[df['level']<=sliderVal]['label'],
            #values = df[df['level']<=sliderVal]['value'],
            parents = df[df['level']<=sliderVal]['parent'],
            hovertext=df[df['level']<=sliderVal]['hovertext']
        ))
        fig.update_traces(root_color="#f1f1f1")
        fig.update_layout(width = 900, height = 900)


        return fig
