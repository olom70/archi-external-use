import logging
import archi.configarchi as conf
import networkx as nx

from archi.parsexml import log_function_call

mlogger = logging.getLogger('archi-external-use.exploitgraph')

@log_function_call
def prepareBusinessCapabilitiesTreemap(viewAsGraph: nx.MultiDiGraph) -> conf.Lists:
    '''
        This function is dedicatd to archi views with only nodes having a composition or a  aggregations edges
        It generates the lists usable by pandas and plotly
    '''

    @log_function_call
    def assignParents(lists: conf.Lists) -> None:
        if len(lists.childs) > 0:
            for k, v in lists.childs.items():
                mlogger.debug(f'key : {k}, value : {v}')
                if len(v) > 0:
                    for child in v:
                        try:
                            i = lists.ids.index(child)
                            lists.parents[i] = k
                        except ValueError:
                            mlogger.warning('Child node ({child}) not found in lists.ids. Strange, a bug must lie within the code')
        else:
            mlogger.debug('lists.childs is empty')

    @log_function_call
    def walkgraph(MDG: nx.MultiDiGraph,  names: dict, current_node: list, startLevel: int, lists: conf.Lists) -> tuple:

        @log_function_call
        def continue_walk(e: dict) -> bool:
            mlogger.debug(f'dictionnary received : {e}')
            relationshipValues = [v for v in e[0].values()]
            listOk = [r for r in conf.SuitableRelationship.list() if r in relationshipValues]
            if len(listOk) > 0:
                mlogger.debug('found a suitableRelationship -> returning True')
                return True
            else:
                return False
                        
        mlogger.debug(f'current_node : {current_node}')
        levelPlusOne = startLevel + 1
        nextNodes = []

        try:
            if len(nx.edges(MDG, current_node)) > 0:
                childedges = nx.edges(MDG, current_node)
                for e in childedges:
                    mlogger.debug(f"edges : {e}")
                    mlogger.debug(f"list of edges {MDG.adj[e[0]][e[1]]}")

                    # Add the first node in the list                
                    if e[0] not in lists.ids: 
                        lists.ids.append(e[0])
                        lists.levels.append(startLevel)
                        lists.parents.append('')
                        try:
                            lists.names.append(names[e[0]])
                            lists.textsinfo.append(names[e[0]])
                        except ValueError as ve:
                            mlogger.info(f"the node {e[0]} has no name")
                    if e[0] not in lists.childs:
                        lists.childs[e[0]] = []
                    try:
                        i = nextNodes.index(e[1]) #if there are several edges betweens e[0] and e[1] this test prevents duplicates
                    except ValueError:
                        if continue_walk(MDG.adj[e[0]][e[1]]):
                            nextNodes.append(e[1])
                            lists.ids.append(e[1])
                            lists.levels.append(levelPlusOne)
                            lists.parents.append('')
                            try:
                                lists.names.append(names[e[1]])
                                lists.textsinfo.append(names[e[1]])
                            except ValueError as ve:
                                mlogger.info(f"the node {e[1]} has no name")
                            ch = lists.childs[e[0]]
                            ch.append(e[1])
                walkgraph(MDG, names, nextNodes, levelPlusOne, lists)
            else: # I reached the leaves
                    for l in current_node:
                        try:
                            i = lists.ids.index(l)
                        except ValueError:
                            lists.ids.append(l)
                            lists.levels.append(startLevel)
                            lists.parents.append('')
                            try:
                                lists.names.append(names[l])
                                lists.textsinfo.append(names[l])
                            except ValueError as ve:
                                mlogger.info(f"the node {l} has no name")
        except Exception as e:
            mlogger.critical(f'Unexpected error in function prepareCapabilitiesTreemap() : {type(e)}{e.args}')

    lists = conf.Lists()
    listOfTopLevelsNodes = [n for n,d in viewAsGraph.in_degree() if d==0]
    if len(listOfTopLevelsNodes) > 0:
        for topLevelNode in listOfTopLevelsNodes:
            mlogger.debug(f'current top node : {topLevelNode}')
            names = nx.get_node_attributes(viewAsGraph, conf.ToStore.EN.value)
            startLevel = 0
            walkgraph(viewAsGraph, names, [topLevelNode], startLevel, lists)
        assignParents(lists)

    return lists

