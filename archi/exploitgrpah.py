import logging
from typing import List
import archi.configarchi as conf
import networkx as nx

from archi.parsexml import log_function_call

mlogger = logging.getLogger('test-archi-external-use.graphcreation')

@log_function_call
def prepareBusinessCapabilitiesTreemap(viewAsGraph: nx.MultiDiGraph) -> conf.Lists:
    '''
        This function is dedicatd to archi views with only nodes having a composition or a  aggregations edges
        It generates the lists usable by pandas and plotly
    '''

    def walkgraph(MDG: nx.MultiDiGraph,  names: dict, current_node: list, currentLevel: int, lists: conf.Lists) -> tuple:

        @log_function_call
        def continue_walk(e: dict) -> bool:
            mlogger.debug(f'dictionnary received : {e}')
            relationshipValues = [v for v in e[0].values()]
            listOk = [r for r in conf.SuitableRelationship.list() if r in relationshipValues]
            if len(listOk) > 0:
                mlogger.debug('found a suitableRelationship -> returning True')
                return True
            else:
                return False
        
        mlogger.debug(f'current_node : {current_node}')
        nextLevel = currentLevel + 1
        nextNodes = []

        try:
            if len(nx.edges(MDG, current_node)) > 0:
                for e in nx.edges(MDG, current_node):
                    mlogger.debug(f"edges : {e}")
                    mlogger.debug(f"list of edges {MDG.adj[e[0]][e[1]]}")

                    # Add the first node in the list                
                    lists.ids.append(e[0])
                    lists.levels.append(currentLevel)
                    lists.parents.append('') if currentLevel == 0 else lists.parents.append(lists.ids[len(lists.ids)-1])
                    try:
                        lists.names.append(names[e[0]])
                        lists.textsinfo.append(names[e[0]])
                    except ValueError as ve:
                        mlogger.info(f"the node {e[0]} has no name")
                    
                    try:
                        i = nextNodes.index(e[1])
                    except ValueError:
                        if continue_walk(MDG.adj[e[0]][e[1]]):
                            nextNodes.append(e[1])                
                walkgraph(MDG, names, nextNodes, nextLevel, lists)
            else: # I reached the leaves
                if currentLevel > 0:
                    parent = lists.ids(len(lists.ids)-1)
                else:
                    parent = ''
                for n in current_node:
                    lists.ids.append(n)
                    lists.parents.append(parent)
                    try:
                        lists.names.append(names[n])
                        lists.textsinfo.append(names[n])
                    except ValueError as ve:
                        mlogger.info(f"the node {n} has no name")
        except Exception as e:
            mlogger.critical(f'Unexpected error in function prepareCapabilitiesTreemap() : {type(e)}{e.args}')

    lists = conf.Lists()
    listOfTopLevelsNodes = [n for n,d in viewAsGraph.in_degree() if d==0]
    if len(listOfTopLevelsNodes) > 0:
        for topLevelNode in listOfTopLevelsNodes:
            mlogger.debug(f'current top node : {topLevelNode}')
            names = nx.get_node_attributes(viewAsGraph, conf.ToStore.EN.value)
            currentLevel = 0
            walkgraph(viewAsGraph, names, [topLevelNode], currentLevel, lists)
    return lists

            

